---
output: github_document
---

<!-- badges: start -->
[![R-CMD-check](https://github.com/emilio-berti/assembly/workflows/R-CMD-check/badge.svg)](https://github.com/emilio-berti/assembly/actions)
<!-- badges: end -->


<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  fig.width = 4,
  fig.height = 4,
  fig.align='center',
  dpi = 300,
  out.width = "50%"
)
```

# Example workflow

Following food web terminology, I talk here about _resources_ and _consumers_. In the case of plant-pollinator networks, this is analogous as replacing _resource_ with _plant_ and _consumers_ with _pollinator_. In this case, however, some filtering steps may be unnecessary and unwanted. __More about this in a separate section.__

I show an example workflow that is composed of the following steps:

1. draw random species from a metaweb
2. impose resource filtering, i.e. each basal species must be consumed and each consumer must feed on a resource.
3. impose limiting similarity filtering, i.e. consumers are constantly replaced by others following a probability distribution proportional to their similarity of interactions. 

## Draw random species from a metaweb

Loading the required libraries and set a random seed:

```{r init}
library(assembly)
library(igraph)

set.seed(1234)
```

Load the dataset _adirondack_ that comes with _assembly_:

```{r adirondack}
data(adirondack)
```

_adirondack_ is the Adirondack Lakes metaweb as obtained from the GATEWAy database.

Define the number of species for the local community:
```{r S}
S <- 50 #species richness
```

To draw a random community, use the function `draw_random_species()`:

```{r random}
sp <- draw_random_species(S, colnames(adirondack))
sum(colSums(adirondack[sp, sp]) == 0) #20 basal speciesshow_fw(sp, adirondack, title = "Random")
plot(graph_from_adjacency_matrix(adirondack[sp, sp]), vertex.label = NA)
```

## Hidden functions

There are several hidden functions in _assembly_. The reason there are hidden functions is because there is no need to call them directly. Hidden functions can be accessed by prefixing the `assembly:::` (three colon, not two). All hidden functions start with a dot `.`, e.g. `assembly:::.basals()`.

In general, you should not be bothered by hidden functions and should not call them directly, unless you have a good understanding of how they operate. Nevertheless, I summarize them for clarity.

`assembly:::.basals()` get all basal species in the metaweb, and is equivalent to subset the names of the metaweb where `colSums(metaweb) == 0`:

```{r basals}
identical(
  sort(intersect(assembly:::.basals(adirondack), sp)),
  sort(intersect(colnames(adirondack)[colSums(adirondack) == 0], sp))
)
```

`assembly:::.consumers()` and `assembly:::.top()` return the consumers and top consumers of the metaweb, respectively.

`assembly:::.find_isolated()` returns the species that are isolated in the local community:

```{r find_isolated}
assembly:::.find_isolated(sp, adirondack)
```
`assembly:::.find_replacements()` find suitable replacement for the isolated species:

```{r find_replacements}
assembly:::.find_replacements(sp,
                              assembly:::.find_isolated(sp, adirondack),
                              adirondack,
                              keep.n.basal = TRUE)
```

If _keep.n.basal_ is TRUE (default = FALSE), then the original number of basal species will not change.

`assembly:::.move()` performs a move in the limiting similarity procedure (more about this later):

```{r move}
tryCatch(assembly:::.move(sp, adirondack, t = 1),
         error = function(e) print(e))
```

This call to `assembly:::.move()` fails because isolated species are detected in the input. This is a desired property of the function, i.e. it fails when there is an unexpected behavior. All hidden functions have some kind of behavior-check, which is a safety net to assure the code is doing what you asked for.

Finally, `assembly:::.components()` returns the number of connected components in the graph of the local community:

```{r components}
assembly:::.components(sp, adirondack)
```

Usually, a proper food web has only one component, i.e. all species are connected by a path. Having more than one component means that the food web is actually made of several disconnected communities. In the case above, it also means that at least one of this disconnected communities is composed of only one isolated species.

## Resouce filtering

To impose the resource filtering, I call the function `resource_filtering()`. This takes as input the species names, the metaweb, and an optional argument _keep.n.basal_ to specify weather the original number of basal species should be kept constant (default = `FALSE`). **NOTE this may not be implemented correctly**

Behind the curtain, `resource_filtering()` calls the hidden functions as a way to compress code and make it consistent. That's why you shouldn't bother too much about hidden functions: they're there because they're useful in the development of the package, rather than for your usage. If they're useful for you and you understand how they work, use them.

```{r resource, fig.align='center', fig.width=4, fig.height=4}
sp_resource <- resource_filtering(sp, adirondack, keep.n.basal = TRUE)
show_fw(sp_resource, adirondack, title = "Resource filtering")
plot(graph_from_adjacency_matrix(adirondack[sp_resource, sp_resource]),
     vertex.label = NA)
```

Now the local community is fully connected, i.e. basal species always have a consumer and consumers always have an available resource. It's possible to check this manually calling the hidden functions and working on the adjacency matrix of the local community:

```{r check_connected}
bas <- intersect(sp_resource, assembly:::.basals(adirondack))
cons <- intersect(sp_resource, assembly:::.consumers(adirondack))
all(rowSums(adirondack[bas, cons]) > 0)
all(colSums(adirondack[union(bas, cons), cons]) > 0)
```

Usually you don't need to perform these checks, as I implemented them within  `resource_filtering()`. I also implemented a check for disconnected components, to make sure that the resulting community has no isolated species and only one actual community. 

Bonus: because of these checks, now it is safe to perform a move of the limiting similarity procedure:

```{r fail}
assembly:::.move(sp_resource, adirondack, t = 1)
```

## Limiting similarity filtering

**To come**

## Example 1: Trophic levels in random and filtered communities

For 50 local communities I:

1. draw random species
2. apply the resource filtering procedure
3. calculate the trophic level of the species in the local communities
4. I calculate average and maximum trophic levels within each community

```{r trolev}
# TL_random <- matrix(NA, S, 50)
# TL_resource <- matrix(NA, S, 50)
# for (i in seq_len(50)) {
#   sp <- draw_random_species(S, colnames(adirondack))
#   sp_resource <- resource_filtering(sp, adirondack, keep.n.basal = TRUE)
#   TL_random[, i] <- ATNr::TroLev(adirondack[sp, sp])[, 1]
#   TL_resource[, i] <- ATNr::TroLev(adirondack[sp_resource, sp_resource])[, 1]
# }
# plot(colMeans(TL_random), colMeans(TL_resource),
#      xlim = c(1.1, 2.2), ylim = c(1.1, 2.2),
#      main = "Average trophic level",
#      xlab = "Random communities",
#      ylab = "Resource filtered communities")
# abline(0, 1)
# plot(apply(TL_random, 2, max), apply(TL_resource, 2, max),
#      xlim = c(2.2, 9.2), ylim = c(2.2, 9.2),
#      main = "Maximum trophic level",
#      xlab = "Random communities",
#      ylab = "Resource filtered communities")
# abline(0, 1)
```

Trophic level tend to be higher in resource-filtered communities compared to random communities. This is due to isolated consumers (trophic level = 1) in the random communities and that were replaced by connected consumers when imposing resource filtering. It's also evident when computing the number of connected components:

```{r}
show_fw(sp, adirondack)
assembly:::.components(sp, adirondack)

show_fw(sp_resource, adirondack)
assembly:::.components(sp_resource, adirondack)
```
